# Selection statements

- In C most statements besides return and the expression from chapter 4 only fall into 3 categories:
    - Selection statement like if or switch.
    - Iteration statements like loops.
    - Jump statements like break, continue and the already know return.

- The other statements are the compound which groups other statements together and the null statement.
- In C there is no inherent boolean type. The comparison "i < j" either gives 0 (false) or 1 (true).
- With relational operators mixed types are allowed.
- The relational operator is left associative! 
- The expression i < j < k but evaluates with associativity to (i < j) < k, where the parenthesis are either 0 or 1!
- Equality operators (== and !=) have lower precedence than relational operators.
- Logical Operators && and || do "short circuit" evaluation. This means if the value can be deduced from the left alone then the right is not evaluated!
- The above fact makes it great for catching special cases like dividing by zero! E.g. (i != 0) && (j / i > 0)
- Precedence of ! (not) is the same as unary + or - and the precedence of && and || is lower than that of relational operators.
- ! is right associtive and && and || are left associative.
- Compound statement refers to the { } braces which come after ifs and loops which groups several statements as one block together to be executed upon the loop or conditional.
- The "else if" statement does not actually exist! It is just a convenient way to not nest cascaded if statements too much.
- The precedence of the conditional operator e1 ? e2 : e3 is one of the lowest there is (expet for assignment =)
- One can define new Variable types in the preprocessor `#define BOOL int` and then using it like `BOOL flag = 1;` for true. However type definitions or enumerations might be a better way.
- C99 introduces the `_Bool` type. Which is an unsigned int but can only be assigned 1 or 0. You can write `_Bool flag = 5` however it will be assigned 1.
- Arithemtic is also allowed on `_Bool` types but not advisable!
- C99 provides <stdbool.h> which has a macro `bool` for the `_Bool` variable and provides `true` and `false` for 1 and 0.
- The constant expression in the case statement **must** evaluate to an integer, so only int and characters are allowed.
- One can put the same statement output for several cases like this `case 4: case 3: case 2: case 1: i = 0; break;`
- The above is called a fall through and might be handled with a comment for easier readability.
- A fallthrough is caused because the "controller" goes to the case label matching the value of the switch expression. After it has executed the statement of its label and does not encounter a `break;` it does not evaluate the case labels afterwards but only executes the statements.
- If no default case is given and the value is not caught by the other cases the switch statement just contiues at the next statement after it.
- The conditional warning of gcc with `Wparentheses` and `-Wall` can be suppressed by a second set of parantheses like: `if((i=j))`.
- If in conditional expression int and floats gets mixed the end expression is always of type float, with the respective value.
